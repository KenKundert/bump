#!/usr/bin/env python3
# Description {{{1
"""
Bump version and release date.

The directory must be clean (no uncommitted changes) for the bump to occur. Tag 
is applied for minor and major release, but not patches.

usage:
    bump [options] major [dev|alpha|beta|rc|release]
    bump [options] minor [dev|alpha|beta|rc|release]
    bump [options] patch
    bump [options] [dev|alpha|beta|rc|release]
    bump [options]
    bump initialize
    bump version
    bump [options] clean

options:
    -h, --help      show this help message and exit
    -q, --quiet     run without narration
    -t, --trialrun  create new files rather than updating existing files
"""
__version__ = "2.0.0-alpha.2"
__released__ = "2022-06-06"


# Imports {{{1
from docopt import docopt
from inform import (
    Inform, Error,
    codicil, conjoin, display, error, full_stop, is_collection, os_error,
    output, terminate, warn,
)
from shlib import rm, Run, to_path
from textwrap import dedent
from arrow import now
from voluptuous import Schema, Required, Invalid, MultipleInvalid
import re
import nestedtext as nt


# Globals {{{1
CFG_FILE = ".bump.cfg.nt"
INITIAL_CFG_FILE_VALUES = dict(
    major = 0,
    minor = 0,
    patch = 0,
    version = 0,
    type = "release",
    files = [
        dict(
            path="⟪file-path⟫",
            date="⟪date-variable⟫",
            version="⟪version-variable⟫"
        )
    ]
)
RELEASE_TYPES = ["dev", "alpha", "beta", "rc", "release"]
ASSIGNMENT_REGEX = r"""\b{}(\s*)([:=])(\s*)(["']?){}(['"]?)"""
DATE_FMT = "YYYY-MM-DD"
DATE_REGEX = r"\d\d\d\d-\d?\d-\d?\d"
VERSION_REGEX = r"\d+\.\d+\.\d+(?:-\w+\.\d+)?"
NEW_EXTENSION = ".new"
REVISION_CONTROL_COMMANDS = {
    "git": {
        "status_command": "git status -s",
        "commit_command": [
            "git add .",
            "git commit -m 'bump version to {version}'",
        ],
        "tag_command": [
            "git tag -s v{version} -m 'bump version to {version}'",
            "git push origin v{version}"
        ],
    },
    "hg": {
        "status_command": "hg status -q",
        "commit_command": "hg commit -m 'bump version to {version}'",
        "tag_command": "hg tag v{version} -m 'bump version to {version}'",
    },
}

# create schema for config file {{{2
voluptuous_error_msg_mapings = {
    "extra keys not allowed": "unknown key",
}

def downcase(key, _):
    return key.lower()

def as_number(arg):
    try:
        value = int(arg)
        if value >= 0:
            return value
    except ValueError:
        pass
    raise Invalid("expected whole number.")

def as_release_type(arg):
    if arg not in RELEASE_TYPES:
        raise Invalid(f"unrecognized type, choose from {conjoin(RELEASE_TYPES)}.")
    return arg

def as_path(arg):
    path = to_path(arg)
    if path.exists():
        return path
    raise Invalid(f"path does not exist.")

def as_identifier(arg):
    if arg.isidentifier():
        return arg
    raise Invalid(f"expected an identifier.")

validate_config = Schema({
    Required("major"): as_number,
    Required("minor"): as_number,
    Required("patch"): as_number,
    Required("revision"): as_number,
    Required("type"): as_release_type,
    Required("files"): {as_path: dict(date=as_identifier, version=as_identifier)}
})


# utility functions {{{1
def render_version(cfg):
    if cfg["type"] == "release":
        return "{major}.{minor}.{patch}".format(**cfg)
    else:
        return "{major}.{minor}.{patch}-{type}.{revision}".format(**cfg)

try:
    # Read the command line {{{1
    cmdline = docopt(__doc__)
    Inform(quiet = cmdline["--quiet"])
    extension = NEW_EXTENSION if cmdline["--trialrun"] else ""

    # clean old --trialrun files if requested {{{1
    if cmdline["clean"]:
        to_remove = list(to_path('.').glob("**/*" + NEW_EXTENSION))
        if cmdline["--trialrun"]:
            if to_remove:
                output("To remove:", *to_remove, sep="\n    ")
            else:
                output("Nothing to remove.")
        else:
            rm(to_remove)
        terminate()

    # Determine the revision control system in use {{{1
    if to_path(".git").exists():
        status_command = REVISION_CONTROL_COMMANDS["git"]["status_command"]
        commit_command = REVISION_CONTROL_COMMANDS["git"]["commit_command"]
        tag_command = REVISION_CONTROL_COMMANDS["git"]["tag_command"]
    elif to_path(".hg").exists():
        status_command = REVISION_CONTROL_COMMANDS["hg"]["status_command"]
        commit_command = REVISION_CONTROL_COMMANDS["hg"]["commit_command"]
        tag_command = REVISION_CONTROL_COMMANDS["hg"]["tag_command"]
    else:
        status_command = None
        commit_command = []
        tag_command = []
        warn("could not determine revision control system.")
        codicil("Expected presence of ./.git or ./.hg.")

    # Create initial config file and exit if requested {{{1
    if cmdline["initialize"]:
        nt.dump(INITIAL_CFG_FILE_VALUES, CFG_FILE + extension, default=str)
        terminate()

    # Otherwise, read config file {{{1
    cfg = nt.load(CFG_FILE, top=dict, keymap=(keymap:={}))
    cfg = validate_config(cfg)

    # output version if requested {{{1
    if cmdline["version"]:
        output(render_version(cfg))
        terminate()

    # determine requested level {{{1
    LEVELS = ["patch", "minor", "major"]
    requested_level = None
    for l in LEVELS:
        if cmdline[l]:
            assert requested_level is None
            requested_level = l

    # determine requested type {{{1
    TYPES = ["dev", "alpha", "beta", "rc", "release"]
    requested_type = None
    for t in TYPES:
        if cmdline[t]:
            assert requested_type is None
            requested_type = t

    # determine new version {{{1
    if cfg["type"] == "release":
        if requested_level == "major":
            cfg["major"] += 1
            cfg["minor"] = 0
            cfg["patch"] = 0
            cfg["revision"] = 0
            cfg["type"] = "release"
        elif requested_level == "minor":
            cfg["minor"] += 1
            cfg["patch"] = 0
            cfg["revision"] = 0
            cfg["type"] = "release"
        else:
            cfg["patch"] += 1
            cfg["revision"] = 0
            cfg["type"] = "release"

        if requested_type:
            cfg["type"] = requested_type

    elif requested_type == "release":
        cfg["revision"] = 0
        cfg["type"] = "release"

    else:
        if requested_type and requested_type != cfg["type"]:
            cfg["type"] = requested_type
            cfg["revision"] = 0
        else:
            cfg["revision"] += 1
    new_version = render_version(cfg)

    # check for a clean release {{{1
    if status_command:
        cmd = status_command.format()
        check = Run(cmd, "sOeW")
        clean = check.stdout.strip() == ""
        if cmdline["--trialrun"]:
            display("clean" if clean else "dirty", "release.")
        if not clean:
            if cmdline["--trialrun"]:
                warn("uncommitted files.")
            else:
                raise Error("uncommitted files.")

    # update the variables {{{1
    new_date = now().format(DATE_FMT)
    for path, variables in cfg['files'].items():
        rm(str(path) + NEW_EXTENSION)
        contents = orig_contents = path.read_text()

        if 'date' in variables:
            varname = variables['date']
            matcher = re.compile(ASSIGNMENT_REGEX.format(varname, DATE_REGEX))
            new_assign = rf"{varname}\1\2\3\g<4>{new_date}\5"
            new_contents = matcher.sub(new_assign, contents)
            if new_contents != contents:
                display("date updated.", culprit=path)
                contents = new_contents
            elif not matcher.search(contents):
                warn("date assignment not found.", culprit=(path, varname))

        if 'version' in variables:
            varname = variables['version']
            matcher = re.compile(ASSIGNMENT_REGEX.format(varname, VERSION_REGEX))
            new_assign = rf"{varname}\1\2\3\g<4>{new_version}\5"
            new_contents = matcher.sub(new_assign, contents)
            if new_contents != contents:
                display("version updated.", culprit=path)
                contents = new_contents
            elif not matcher.search(contents):
                warn("version assignment not found.", culprit=(path, varname))

        if contents != orig_contents:
            to_path(str(path) + extension).write_text(contents)

    # update the config file {{{1
    display(f"Updating to version {new_version}.")
    rm(CFG_FILE + NEW_EXTENSION)
    nt.dump(cfg, CFG_FILE + extension, default=str)

    # commit the changes {{{1
    if not is_collection(commit_command):
        commit_command = [commit_command]
    for command in commit_command:
        cmd = command.format(version=new_version)
        if cmdline["--trialrun"]:
            display(cmd)
        else:
            Run(cmd, "soeW")

    # tag the commit {{{1
    if requested_level in ["major", "minor"] and cfg["type"] == "release":
        tag = f"{cfg['major']}.{cfg['minor']}"
        display("applying tag:", tag)

        if not is_collection(tag_command):
            tag_command = [tag_command]

        for command in tag_command:
            cmd = command.format(version=tag)
            if cmdline["--trialrun"]:
                display(cmd)
            else:
                Run(cmd, "soeW")

# exceptions {{{1
except OSError as e:
    error(os_error(e))
except (Error, nt.NestedTextError) as e:
    e.report()
except MultipleInvalid as e:
    for err in e.errors:
        msg = voluptuous_error_msg_mapings.get(err.msg, err.msg)
        kind = "key" if "key" in msg or "path" in msg else "value"
        loc = keymap.get(tuple(err.path))
        codicil = loc.as_line(kind) if loc else None
        keys = nt.join_keys(err.path, keymap=keymap)
        error(
            full_stop(msg),
            culprit = (CFG_FILE, keys),
            codicil = codicil
        )
terminate()
